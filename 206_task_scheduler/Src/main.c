/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/* Intent
 * ----------------------------------------------------------------
 * 1. Implement a task scheduler which schedules multiple user tasks in a round-robin fashion
 * by carrying out context switching operation.
 * 2. This code uses systick_Handler to carry out context switching.
 *
 *
 * Implementation
 * ----------------------------------------------------------------
 * 1. Do stack analysis and define stack boundaries (PSP start) for each task and the scheduler.
 * 2. Store the PSPs for all tasks in a global variable.
 * 3. Declare a global variable to store fn ptrs of all the task handlers.
 * 4. Declare a global variable to store ID of curr task.
 *
 * 5. In main(), enable all p. faults.
 * 6. Store fn ptrs of all the task handlers in the global variable.
 * 7. Init dummy context for all the tasks in their respective stacks - what if T2 is executed for the very first time?
 * 	  No state available in its private stack area to retrieve
 * 8. Init systick timer with TICK_RATE and enable it.
 * 9. Init MSP with SCHD_STACK_START
 * 10. current_task = 0;
 * 11. Load PSP with T1-PSP and switch to PSP
 * 12. Call T1_handler in main()
 * 13. systick_handler will perform context switching -
 * 	   save the context of curr task (p. will store SF-1. s/w should store SF2 and update PSP in global var.)
 *     retrieve the context of next task
 *  */

#include <stdio.h>
#include <stdint.h>
#include "main.h"

void enable_processor_faults(void);

__attribute__((naked)) void schd_sp_init(uint32_t schd_stack_start);
void tasks_dummy_context_init(void);
void systick_init(uint32_t ticks);
uint32_t get_psp_value_into_r0(void);
__attribute__((naked)) void switch_sp_to_psp(void);
void save_psp_value_to_global_var(uint32_t curr_updated_psp_value);

//4 user tasks of the application
void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);

//store PSPs of all the tasks in a global var
uint32_t psp_of_tasks[MAX_TASKS] = {T1_STACK_START, T2_STACK_START, T3_STACK_START, T4_STACK_START};
uint32_t addr_of_task_handlers[MAX_TASKS];
uint8_t current_task = 0; //task1 is running

int main(void)
{
	enable_processor_faults();

	addr_of_task_handlers[0] = (uint32_t) task1_handler; //store addresses of all task handlers in a global var
	addr_of_task_handlers[1] = (uint32_t) task2_handler;
	addr_of_task_handlers[2] = (uint32_t) task3_handler;
	addr_of_task_handlers[3] = (uint32_t) task4_handler;

	tasks_dummy_context_init(); //store valid values in SF-1 and SF-2

	systick_init(TICK_RATE);

	schd_sp_init(SCHD_STACK_START); //init schd SP (MSP) with pre-determined SP value
	current_task = 0;
	switch_sp_to_psp();
	task1_handler(); //This is a fn call -

	while(1);
}


void enable_processor_faults(void) {
	//Enable the faults in SCB->SHCSR
	uint32_t *pSHCSR = (uint32_t *) 0xE000ED24;
	*pSHCSR |= (1 << 16); //MM F
	*pSHCSR |= (1 << 17); //Bus F
	*pSHCSR |= (1 << 18); //Usage F
}


__attribute__((naked)) void schd_sp_init(uint32_t schd_stack_start) {
	__asm volatile("MSR MSP, R0" : : "r"(schd_stack_start) : );
	__asm volatile("BX LR"); //go back to main(), since main() called this fn
}


void systick_init(uint32_t ticks) {
	uint32_t *pSYST_CSR = (uint32_t *) 0xE000E010;
	uint32_t *pSYST_RVR = (uint32_t *) 0xE000E014;
	uint32_t *pSYST_CVR = (uint32_t *) 0xE000E018;

	uint32_t count_value = (SYSTICK_TIM_CLK / ticks) - 1;

	//1. Disable the timer
	*pSYST_CSR &=~ (1 << 0);

	//2. Load the count_value into RVR
	*pSYST_RVR &= ~(0x00FFFFFF); //Clear RVR, only 24 bits are valid. Do not affect reserved bits
	*pSYST_RVR |= count_value; //Load the count_value into RVR

	//3. Clear CVR
	*pSYST_CVR &= ~(0x00FFFFFF);

	//4. Configure CSR
	*pSYST_CSR |= (1 << 1); //trigger systick exception
	*pSYST_CSR |= (1 << 2); //processor clock

	//5. Enable the timer
	*pSYST_CSR |= (1 << 0);
}


void tasks_dummy_context_init(void) {
	uint32_t *pPSP = NULL;
	for(int i=0; i<MAX_TASKS; i++) {
		pPSP = (uint32_t *) psp_of_tasks[i]; //assigning addr to PSP

		pPSP--;
		*pPSP = DUMMY_XPSR; //xPSR

		pPSP--;
		*pPSP = addr_of_task_handlers[i]; //PC(ret addr) - store the addr of task handlers

		pPSP--;
		*pPSP = DUMMY_LR_EXC_RETURN; //LR (EXC_RETURN)

		for(int i=0; i<13; i++) { //Next 13 words in stack = 0 (R12, R3-R0, R11-R4)
			pPSP--;
			*pPSP = 0;
		}

		psp_of_tasks[i] = (uint32_t) pPSP; //update PSP value for each task in global var after init dummy stack
	}
}


void save_psp_value_to_global_var(uint32_t curr_updated_psp_value) {
	psp_of_tasks[current_task] = curr_updated_psp_value;
}


void update_next_task(void) {
	current_task++; //Round-Robin algo
	current_task %= MAX_TASKS;
}


__attribute__((naked)) void SysTick_Handler(void) { //This is the scheduler and also does the context switch
	//1. Save the context of current task - see diagram in TB
	//1.1 Get current running task's PSP value from PSP register into R0
	__asm volatile("MRS R0, PSP");
	//1.2 Use the PSP to store SF2 (R4-R11)
	__asm volatile("STMDB R0!, {R4-R11}"); //can't use PUSH for stacking since SysTick_Handler uses MSP, not PSP
	//1.3 Save the current updated value of PSP to global variable
	__asm volatile("PUSH {LR}");
	__asm volatile("BL save_psp_value_to_global_var");


	//2. Retrieve the context of next task
	//2.1 Decide what is the next task
	__asm volatile("BL update_next_task");
	//2.2 Get its previous PSP value
	__asm volatile("BL get_psp_value_into_r0");
	//2.3 Using that PSP value, retrieve SF2
	__asm volatile("LDMIA R0!, {R4-R11}");
	//2.4 Update PSP and exit
	__asm volatile("MSR PSP, R0");
	__asm volatile("POP {LR}");
	__asm volatile("BX LR");

}


void task1_handler(void) { //Task handler is not your normal p. exception handler. It is a C-function.
	while(1) {
		printf("In task-1 handler\n"); //ITM fifo not gaurded. It is a shared resource between multiple tasks. So prints will be overlapped
	}
}


void task2_handler(void) {
	while(1) {
		printf("In task-2 handler\n");
	}
}


void task3_handler(void) {
	while(1) {
		printf("In task-3 handler\n");
	}
}


void task4_handler(void) {
	while(1) {
		printf("In task-4 handler\n");
	}
}


void HardFault_Handler(void) {
	printf("In HardFault_Handler\n");
}


void MemManage_Handler(void) {
	printf("In MemManage_Handler\n");
}


void BusFault_Handler(void) {
	printf("In BusFault_Handler\n");
}


void UsageFault_Handler(void) {
	printf("In UsageFault_Handler\n");
}


uint32_t get_psp_value_into_r0(void) {
	return psp_of_tasks[current_task];
}


__attribute__((naked)) void switch_sp_to_psp(void) {
	//1. First init PSP with task1 stack_start addr - 	//get PSP value of current task
	__asm volatile("PUSH {LR}"); //preserve LR to go back to main()
	__asm volatile("BL get_psp_value_into_r0"); //stack addr of curr task will be stored in R0
	__asm volatile("MSR PSP, R0"); //load the addr into PSP
	__asm volatile("POP {LR}");

	//2. change SP to PSP in CONTROL reg
	__asm volatile("MRS R0, CONTROL"); //read
	__asm volatile("ORR R0, R0, 0x2"); //modify R0 |= (1<<1);
	__asm volatile("MSR CONTROL, R0"); //write back

	//3. Go back to main()
	__asm volatile("BX LR");
}
