/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/* Intent
 * ----------------------------------------------------------------
 * 1. Toggle LEDs:
 * Task/LED-1	1s
 * Task/LED-2	500ms
 * Task/LED-3	250ms
 * Task/LED-4	125ms
 *
 *
 * Implementation
 * ----------------------------------------------------------------
 * 1.
 *
 *
 * Actual behaviour
 * ----------------------------------------------------------------
 * 1. LED toggling is delayed by 4 times the specified delay - s/w based delay (for-loop) watses
 * 	  CPU cycles.
 *  */

#include <stdio.h>
#include <stdint.h>
#include "main.h"
#include "led.h"

void enable_processor_faults(void);

__attribute__((naked)) void schd_sp_init(uint32_t schd_stack_start);
void tasks_dummy_context_init(void);
void systick_init(uint32_t ticks);
uint32_t get_psp_value_into_r0(void);
__attribute__((naked)) void switch_sp_to_psp(void);
void save_psp_value_to_global_var(uint32_t curr_updated_psp_value);

//4 user tasks of the application
void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);

//store PSPs of all the tasks in a global var
uint32_t psp_of_tasks[MAX_TASKS] = {T1_STACK_START, T2_STACK_START, T3_STACK_START, T4_STACK_START};
uint32_t addr_of_task_handlers[MAX_TASKS];
uint8_t current_task = 0; //task1 is running

int main(void)
{
	enable_processor_faults();

	addr_of_task_handlers[0] = (uint32_t) task1_handler; //store addresses of all task handlers in a global var
	addr_of_task_handlers[1] = (uint32_t) task2_handler;
	addr_of_task_handlers[2] = (uint32_t) task3_handler;
	addr_of_task_handlers[3] = (uint32_t) task4_handler;

	tasks_dummy_context_init(); //store valid values in SF-1 and SF-2

	led_init_all();
	systick_init(TICK_RATE);

	schd_sp_init(SCHD_STACK_START); //init schd SP (MSP) with pre-determined SP value
	current_task = 0;
	switch_sp_to_psp();
	task1_handler(); //This is a fn call -

	while(1);
}


void enable_processor_faults(void) {
	//Enable the faults in SCB->SHCSR
	uint32_t *pSHCSR = (uint32_t *) 0xE000ED24;
	*pSHCSR |= (1 << 16); //MM F
	*pSHCSR |= (1 << 17); //Bus F
	*pSHCSR |= (1 << 18); //Usage F
}


__attribute__((naked)) void schd_sp_init(uint32_t schd_stack_start) {
	__asm volatile("MSR MSP, R0" : : "r"(schd_stack_start) : );
	__asm volatile("BX LR"); //go back to main(), since main() called this fn
}


void systick_init(uint32_t ticks) {
	uint32_t *pSYST_CSR = (uint32_t *) 0xE000E010;
	uint32_t *pSYST_RVR = (uint32_t *) 0xE000E014;
	uint32_t *pSYST_CVR = (uint32_t *) 0xE000E018;

	uint32_t count_value = (SYSTICK_TIM_CLK / ticks) - 1;

	//1. Disable the timer
	*pSYST_CSR &=~ (1 << 0);

	//2. Load the count_value into RVR
	*pSYST_RVR &= ~(0x00FFFFFF); //Clear RVR, only 24 bits are valid. Do not affect reserved bits
	*pSYST_RVR |= count_value; //Load the count_value into RVR

	//3. Clear CVR
	*pSYST_CVR &= ~(0x00FFFFFF);

	//4. Configure CSR
	*pSYST_CSR |= (1 << 1); //trigger systick exception
	*pSYST_CSR |= (1 << 2); //processor clock

	//5. Enable the timer
	*pSYST_CSR |= (1 << 0);
}


void tasks_dummy_context_init(void) {
	uint32_t *pPSP = NULL;
	for(int i=0; i<MAX_TASKS; i++) {
		pPSP = (uint32_t *) psp_of_tasks[i]; //assigning addr to PSP

		pPSP--;
		*pPSP = DUMMY_XPSR; //xPSR

		pPSP--;
		*pPSP = addr_of_task_handlers[i]; //PC(ret addr) - store the addr of task handlers

		pPSP--;
		*pPSP = DUMMY_LR_EXC_RETURN; //LR (EXC_RETURN)

		for(int i=0; i<13; i++) { //Next 13 words in stack = 0 (R12, R3-R0, R11-R4)
			pPSP--;
			*pPSP = 0;
		}

		psp_of_tasks[i] = (uint32_t) pPSP; //update PSP value for each task in global var after init dummy stack
	}
}


void save_psp_value_to_global_var(uint32_t curr_updated_psp_value) {
	psp_of_tasks[current_task] = curr_updated_psp_value;
}


void update_next_task(void) {
	current_task++; //Round-Robin algo
	current_task %= MAX_TASKS;
}


__attribute__((naked)) void SysTick_Handler(void) { //This is the scheduler and also does the context switch
	//1. Save the context of current task - see diagram in TB
	//1.1 Get current running task's PSP value from PSP register into R0
	__asm volatile("MRS R0, PSP");
	//1.2 Use the PSP to store SF2 (R4-R11)
	__asm volatile("STMDB R0!, {R4-R11}"); //can't use PUSH for stacking since SysTick_Handler uses MSP, not PSP
	//1.3 Save the current updated value of PSP to global variable
	__asm volatile("PUSH {LR}");
	__asm volatile("BL save_psp_value_to_global_var");


	//2. Retrieve the context of next task
	//2.1 Decide what is the next task
	__asm volatile("BL update_next_task");
	//2.2 Get its previous PSP value
	__asm volatile("BL get_psp_value_into_r0");
	//2.3 Using that PSP value, retrieve SF2
	__asm volatile("LDMIA R0!, {R4-R11}");
	//2.4 Update PSP and exit
	__asm volatile("MSR PSP, R0");
	__asm volatile("POP {LR}");
	__asm volatile("BX LR");

}


void task1_handler(void) { //Task handler is not your normal p. exception handler. It is a C-function.
	while(1) {
		led_on(LED_BLUE);
		delay(DELAY_COUNT_1S);
		led_off(LED_BLUE);
		delay(DELAY_COUNT_1S);
	}
}


void task2_handler(void) {
	while(1) {
		led_on(LED_GREEN);
		delay(DELAY_COUNT_500MS);
		led_off(LED_GREEN);
		delay(DELAY_COUNT_500MS);
	}
}


void task3_handler(void) {
	while(1) {
		led_on(LED_ORANGE);
		delay(DELAY_COUNT_250MS);
		led_off(LED_ORANGE);
		delay(DELAY_COUNT_250MS);
	}
}


void task4_handler(void) {
	while(1) {
		led_on(LED_RED);
		delay(DELAY_COUNT_125MS);
		led_off(LED_RED);
		delay(DELAY_COUNT_125MS);
	}
}


void HardFault_Handler(void) {
	printf("In HardFault_Handler\n");
}


void MemManage_Handler(void) {
	printf("In MemManage_Handler\n");
}


void BusFault_Handler(void) {
	printf("In BusFault_Handler\n");
}


void UsageFault_Handler(void) {
	printf("In UsageFault_Handler\n");
}


uint32_t get_psp_value_into_r0(void) {
	return psp_of_tasks[current_task];
}


__attribute__((naked)) void switch_sp_to_psp(void) {
	//1. First init PSP with task1 stack_start addr - 	//get PSP value of current task
	__asm volatile("PUSH {LR}"); //preserve LR to go back to main()
	__asm volatile("BL get_psp_value_into_r0"); //stack addr of curr task will be stored in R0
	__asm volatile("MSR PSP, R0"); //load the addr into PSP
	__asm volatile("POP {LR}");

	//2. change SP to PSP in CONTROL reg
	__asm volatile("MRS R0, CONTROL"); //read
	__asm volatile("ORR R0, R0, 0x2"); //modify R0 |= (1<<1);
	__asm volatile("MSR CONTROL, R0"); //write back

	//3. Go back to main()
	__asm volatile("BX LR");
}
